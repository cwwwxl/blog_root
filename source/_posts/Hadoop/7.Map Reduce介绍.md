---
title: 2.MapReduce
cover: 'https://s2.loli.net/2023/01/19/5JCU6MPaXuSsm1F.jpg'
tags: MapReduce
categories: Hadoop
top_img: 'https://s2.loli.net/2023/01/26/fdwsrm8nyCNUxWg.jpg'
abbrlink: bc1fb66d
---
## 一.Hadoop MapReduce 

### 1.1 理解Map Reduce思想

-  MapReduce的思想核心是“先分再合，分而治之”。
-  所谓“分而治之”就是把一个复杂的问题，按照一定的“分解”方法分为等价的规模较小的若干部分，然后逐个解 决，分别找出各部分的结果，然后把各部分的结果组成整个问题的最终结果。
-  这种思想来源于日常生活与工作时的经验。即使是发布过论文实现分布式计算的谷歌也只是实现了这种思想，而不 是自己原创。

-  Map表示第一阶段，负责“拆分”：即把复杂的任务分解为若干个“简单的子任务”来并行处理。可以进行拆分的 前提是这些小任务可以并行计算，彼此间几乎没有依赖关系。 
-  Reduce表示第二阶段，负责“合并”：即对map阶段的结果进行全局汇总。
-  这两个阶段合起来正是MapReduce思想的体现。

![image-20230110104953917](https://s2.loli.net/2023/01/10/pGRFJhL4Ede76fu.png)

- 一个比较形象的语言解释MapReduce
	- 要数停车场中的所有停放车的总数量。 你数第一列，我数第二列…这就是Map阶段，人越多，能够同时数车的人就越多，速度就越快。 数完之后，聚到一起，把所有人的统计数加在一起。这就是Reduce合并汇总阶段。

![image-20230110105246494](https://s2.loli.net/2023/01/10/DxVsmrvyncG83zX.png)

### 1.2如何对付大数据处理常见

-  对相互间不具有计算依赖关系的大数据计算任务，实现并行最自然的办法就是采取MapReduce分而治之的策略。
-  首先Map阶段进行拆分，把大数据拆分成若干份小数据，多个程序同时并行计算产生中间结果；然后是Reduce聚 合阶段，通过程序对并行的结果进行最终的汇总计算，得出最终的结果。
-  不可拆分的计算任务或相互间有依赖关系的数据无法进行并行计算

![image-20230110120355470](https://s2.loli.net/2023/01/10/hXa3dki7MbOnFf8.png)

### 1.4 构建抽象编程模型

- MapReduce借鉴了函数式语言中的思想，用Map和Reduce两个函数提供了高层的并行编程抽象模型。
	- map: 对一组数据元素进行某种重复式的处理；
	- reduce: 对Map的中间结果进行某种进一步的结果整理。

- MapReduce中定义了如下的Map和Reduce两个抽象的编程接口，由用户去编程实现:
	- map: (k1; v1) → (k2; v2) 
	- reduce: (k2; [v2]) → (k3; v3)

- ​	通过以上两个编程接口，大家可以看出MapReduce处理的数据类型是键值对。

### 1.4 统一架构

- 如何提供统一的计算框架，如果没有统一封装底层细节，那么程序员则需要考虑诸如数据存储、划分、分发、结果 收集、错误恢复等诸多细节；为此，MapReduce设计并提供了统一的计算框架，为程序员隐藏了绝大多数系统层 面的处理细节。 
- MapReduce最大的亮点在于通过抽象模型和计算框架把需要做什么(what need to do)与具体怎么做(how to  do)分开了，为程序员提供一个抽象和高层的编程接口和框架。
- 程序员仅需要关心其应用层的具体计算问题，仅需编写少量的处理应用本身计算问题的业务程序代码
- 至于如何具体完成这个并行计算任务所相关的诸多系统层细节被隐藏起来,交给计算框架去处理：从分布代码的执 行，到大到数千小到单个节点集群的自动调度使用。

### 1.5 分布式计算概念

- 分布式计算是一种计算方法，和集中式计算是相对的。
- 随着计算技术的发展，有些应用需要非常巨大的计算能力才能完成，如果采用集中式计算，需要耗费相当长的时间 来完成。
- 分布式计算将该应用分解成许多小的部分，分配给多台计算机进行处理。这样可以节约整体计算时间，大大提高计 算效率。

![image-20230110123449590](https://s2.loli.net/2023/01/10/sMqNdI56r3fwUXL.png)

### 1.6 MapReduce 介绍

- Hadoop MapReduce是一个分布式计算框架，用于轻松编写分布式应用程序，这些应用程序以可靠，容错的方式 并行处理大型硬件集群（数千个节点）上的大量数据（多TB数据集）。
- MapReduce是一种面向海量数据处理的一种指导思想，也是一种用于对大规模数据进行分布式计算的编程模型。

### 1.7 MapReduce 产生背景

- MapReduce最早由Google于2004年在一篇名为《MapReduce:Simplified Data Processingon Large Clusters 》的论文中提出。 
- 论文中谷歌把分布式数据处理的过程拆分为Map和Reduce两个操作函数（受到函数式编程语言的启发），随后被 Apache Hadoop参考并作为开源版本提供支持，叫做Hadoop MapReduce。
- 它的出现解决了人们在最初面临海量数据束手无策的问题，同时它还是易于使用和高度可扩展的，使得开发者无需 关系分布式系统底层的复杂性即可很容易的编写分布式数据处理程序，并在成千上万台普通的商用服务器中运行。

![image-20230110123955561](https://s2.loli.net/2023/01/10/NpveTs4IZnc2J7X.png)

### 1.8 MapReduce的特点

- 易于编程

Mapreduce框架提供了用于二次开发的接口；简单地实现一些接口，就可以完成一个分布式程序。任务计算交给计算 框架去处理，将分布式程序部署到hadoop集群上运行，集群节点可以扩展到成百上千个等。

- 良好的扩展性

当计算机资源不能得到满足的时候，可以通过增加机器来扩展它的计算能力。基于MapReduce的分布式计算得特点可 以随节点数目增长保持近似于线性的增长，这个特点是MapReduce处理海量数据的关键，通过将计算节点增至几百或 者几千可以很容易地处理数百TB甚至PB级别的离线数据。

- 高容错性

Hadoop集群是分布式搭建和部署得，任何单一机器节点宕机了，它可以把上面的计算任务转移到另一个节点上运行， 不影响整个作业任务得完成，过程完全是由Hadoop内部完成的。

- 适合海量数据的离线处理

可以处理GB、TB和PB级别得数据量

### 1.9MapReduce 局限性

​	MapReduce虽然有很多的优势，也有相对得局限性，局限性不代表不能做，而是在有些场景下实现的效果比较差，并 不适合用MapReduce来处理，主要表现在以下结果方面：

- 实时计算性能差

​	MapReduce主要应用于离线作业，无法作到秒级或者是亚秒级得数据响应。

- 不能进行流式计算

​	流式计算特点是数据是源源不断得计算，并且数据是动态的；而MapReduce作为一个离线计算框架，主要是针对静态 数据集得，数据是不能动态变化得。

### 2.0 MapReduce实例进程

一个完整的MapReduce程序在分布式运行时有三类

- MRAppMaster：负责整个MR程序的过程调度及状态协调
- MapTask：负责map阶段的整个数据处理流程
- ReduceTask：负责reduce阶段的整个数据处理流程

### 2.1 阶段组成

- 一个MapReduce编程模型中只能包含一个Map阶段和一个Reduce阶段，或者只有Map阶段；
- 不能有诸如多个map阶段、多个reduce阶段的情景出现； 
- 如果用户的业务逻辑非常复杂，那就只能多个MapReduce程序串行运行。

![image-20230110125013189](https://s2.loli.net/2023/01/10/sr8W4CMHNZRFI7J.png)

### 2.2 MapRedece数据类型

- 注意：整个MapReduce程序中，数据都是以kv键值对的形式流转的；
- 在实际编程解决各种业务问题中，需要考虑每个阶段的输入输出kv分别是什么；
- MapReduce内置了很多默认属性，比如排序、分组等，都和数据的k有关，所以说kv的类型数据确定及其重要的

### 2.3 map阶段的执行过程

- 第一阶段：把输入目录下文件按照一定的标准逐个进行逻辑切片，形成切片规划。 默认Split size = Block size（128M），每一个切片由一个MapTask处理。（getSplits）
- 第二阶段：对切片中的数据按照一定的规则读取解析返回对。 默认是按行读取数据。key是每一行的起始位置偏移量，value是本行的文本内容。（TextInputFormat）
- 第三阶段：调用Mapper类中的map方法处理数据。 每读取解析出来的一个 ，调用一次map方法。
- 第四阶段：按照一定的规则对Map输出的键值对进行分区partition。默认不分区，因为只有一个reducetask。 分区的数量就是reducetask运行的数量。
- 第五阶段：Map输出数据写入内存缓冲区，达到比例溢出到磁盘上。溢出spill的时候根据key进行排序sort。 默认根据key字典序排序。 
- 第六阶段：对所有溢出文件进行最终的merge合并，成为一个文件。

### 2.4 reduce阶段的执行过程

- 第一阶段：ReduceTask会主动从MapTask复制拉取属于需要自己处理的数据。
- 第二阶段：把拉取来数据，全部进行合并merge，即把分散的数据合并成一个大的数据。再对合并后的数据排序 。 
- 第三阶段是对排序后的键值对调用reduce方法。键相等的键值对调用一次reduce方法。最后把这些输出的键值对 写入到HDFS文件中。

## 二 .shffle概念

### 1.1 shffle概念

- Shuffle的本意是洗牌、混洗的意思，把一组有规则的数据尽量打乱成无规则的数据。
- 而在MapReduce中，Shuffle更像是洗牌的逆过程，指的是将map端的无规则输出按指定的规则“打乱”成具有一 定规则的数据，以便reduce端接收处理。
- 一般把从Map产生输出开始到Reduce取得数据作为输入之前的过程称作shuffle。

### 1.2 Map端Shuffle

- Collect阶段：将MapTask的结果收集输出到默认大小为100M的环形缓冲区，保存之前会对key进行分区的计算， 默认Hash分区。 
- Spill阶段：当内存中的数据量达到一定的阀值的时候，就会将数据写入本地磁盘，在将数据写入磁盘之前需要对数 据进行一次排序的操作，如果配置了combiner，还会将有相同分区号和key的数据进行排序。
- Merge阶段：把所有溢出的临时文件进行一次合并操作，以确保一个MapTask最终只产生一个中间数据文件。

### 1.3 Reducer端shuffle

- Copy阶段： ReduceTask启动Fetcher线程到已经完成MapTask的节点上复制一份属于自己的数据。
- Merge阶段：在ReduceTask远程复制数据的同时，会在后台开启两个线程对内存到本地的数据文件进行合并操作 。 
- Sort阶段：在对数据进行合并的同时，会进行排序操作，由于MapTask阶段已经对数据进行了局部的排序， ReduceTask只需保证Copy的数据的最终整体有效性即可。

### 1.4 shuffle弊端

- Shuffle是MapReduce程序的核心与精髓，是MapReduce的灵魂所在。 
- Shuffle也是MapReduce被诟病最多的地方所在。MapReduce相比较于Spark、Flink计算引擎慢的原因，跟 Shuffle机制有很大的关系。
- Shuffle中频繁涉及到数据在内存、磁盘之间的多次往复。

## 三.Hadoop YARN介绍

### 1.1 YARN简介

- Apache Hadoop YARN （Yet Another Resource Negotiator，另一种资源协调者）是一种新的Hadoop资源管 理器。
- YARN是一个通用资源管理系统和调度平台，可为上层应用提供统一的资源管理和调度。 
- 它的引入为集群在利用率、资源统一管理和数据共享等方面带来了巨大好处。

![image-20230110155522061](https://s2.loli.net/2023/01/10/PwjcanVFeWY7CDq.png)

### 1.2 YARN 功能

- 资源管理系统：集群的硬件资源，和程序运行相关，比如内存、CPU等。
- 调度平台：多个程序同时申请计算资源如何分配，调度的规则（算法）。
- 通用：不仅仅支持MapReduce程序，理论上支持各种计算程序。YARN不关心你干什么，只关心你要资源，在有 的情况下给你，用完之后还我。

### 1.3 YARW概述

- 可以把Hadoop YARN理解为相当于一个分布式的操作系统平台，而MapReduce等计算程序则相当于运行于操作 系统之上的应用程序，YARN为这些程序提供运算所需的资源（内存、CPU等）。 
- Hadoop能有今天这个地位，YARN可以说是功不可没。因为有了YARN ，更多计算框架可以接入到 HDFS中，而 不单单是 MapReduce，正是因为YARN的包容，使得其他计算框架能专注于计算性能的提升。
- HDFS可能不是最优秀的大数据存储系统，但却是应用最广泛的大数据存储系统， YARN功不可没。

### 1.4 YARW3大组件

- ResourceManager（RM）

​	YARN集群中的主角色，决定系统中所有应用程序之间资源分配的最终权限，即最终仲裁者。 接收用户的作业提交，并通过NM分配、管理各个机器上的计算资源。

-  NodeManager（NM）

​	YARN中的从角色，一台机器上一个，负责管理本机器上的计算资源。 根据RM命令，启动Container容器、监视容器的资源使用情况。并且向RM主角色汇报资源使用情况。

- ApplicationMaster（AM）

​	用户提交的每个应用程序均包含一个AM。 应用程序内的“老大”，负责程序内部各阶段的资源申请，监督程序的执行情况。

### 1.5 调度器策略

-  三种调度器 FIFO Scheduler（先进先出调度器）、Capacity Scheduler（容量调度器）、Fair Scheduler（公平调度器）。
-  Apache版本YARN默认使用Capacity Scheduler。
-  如果需要使用其他的调度器，可以在yarn-site.xml中的yarn.resourcemanager.scheduler.class进行配置。

### 1.6 FIFO Scheduler概述

- FIFO Scheduler是Hadoop1.x中JobTracker原有的调度器实现，此调度器在YARN中保留了下来。 
- FIFO Scheduler是一个先进先出的思想，即先提交的应用先运行。调度工作不考虑优先级和范围，适用于负载较低 的小规模集群。当使用大型共享集群时，它的效率较低且会导致一些问题。 
- FIFO Scheduler拥有一个控制全局的队列queue，默认queue名称为default，该调度器会获取当前集群上所有的 资源信息作用于这个全局的queue。

#### 优势

- 优势： 无需配置、先到先得、易于执行
- 坏处： 任务的优先级不会变高，因此高优先级的作业需要等待 不适合共享集群

